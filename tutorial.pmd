<<switches, echo=False, evaluate=True>>=
text_echo = text_mode and not debug_mode
text_evaluate = False
code_echo = not text_mode
code_evaluate = False
debug_echo = debug_mode
debug_evaluate = debug_mode
@ 

# Oh hey. 

Welcome to the Discover STEM session on Programming for Robot Control.


# Introduction to Python

<<echo=<%=text_echo%>,evaluate = <%=text_evaluate%> >>=
# This is some code that we will use to test your work. 
import checker
import gantryGame
import matplotlib.pyplot as plt
%matplotlib inline

@

<<echo=<%=debug_mode%>, evaluate = <%=debug_mode%> >>=
import checker
import gantryGame
import utils as ut

from importlib import reload
reload(checker)
reload(ut)
reload(gantryGame)

import matplotlib.pyplot as plt
%matplotlib inline

@ 



## Problem

Write a function called `cubed` that takes a number, $x$, as input and returns its cube, $x^3$.

<<echo=<%=text_echo%>, evaluate = <%=text_evaluate%> >>=
# Write your code here. 


# Don't modify this line. It is used to test your code.
checker.check_cubed(cubed)
@ 

<<echo=<%=debug_mode%>, evaluate = True>>=
cubed = lambda x : x**3
checker.check_cubed(cubed)
@ 


<<echo=<%=code_echo%>,evaluate = <%=code_evaluate%> >>=
# This is the main checker code 
import numpy as np
import numpy.random as rnd
import scipy.linalg as la
import scipy.signal as sp
import systems as dsys

def feedback(result):
   if result:
      print("oh yeah.")
   else:
      print("nope")
   return result
def check_array_equality(X,X_test,tol=1e-3,ord=2):
   err = la.norm(X-X_test,ord=ord)

   passed = err < tol
   feedback(passed)
   return passed
      

def check_cubed(fun):
   X = rnd.randn(10)
   Y = X**3
   Y_test = np.array([fun(x) for x in X])
   check_array_equality(Y,Y_test)
@ 

## Why we need feedback

Let's try pushing a block around on a low friction surface. 

<<echo=<%=debug_echo or text_echo%>, evaluate=False>>=

gantryGame.manualControl()
@ 




<<echo=<%=code_echo%>, evaluate = <%=code_evaluate%> >>=
import gantryGame
import matplotlib.pyplot as plt
import scipy.signal as sp
import utils as ut

c = gantryGame.damping
P = ([1.],[1.,c,0])

def unstableRoots(p,tol=1e-8):
   return np.array([r for r in np.roots(p) if np.real(r) >= -tol])

def testClassicalControl(P,C):
   C_min = ut.minreal(C)
   P_min = ut.minreal(P)
   
   CL = ut.classicFeedback(P_min,C_min)
   CL = ut.minreal(CL) 
   

   # Stability Tests
   nP,dP = P_min
   nC,dC = C_min
   
   # First check for  pole-zero cancellations
   nL = np.polymul(nP,nC)
   dL = np.polymul(dP,dC)
  
   L_unstable = unstableRoots(dL)
   L_min = ut.minreal((nL,dL)) 
   L_min_unstable = unstableRoots(L_min[1]) 
   
   if len(L_unstable) > len(L_min_unstable):
      print('Unstable Pole-Zero Cancellation.\nYour system will be sensitive input disturbances.\n')
      return feedback(False)
   
   # Now check if the closed-loop system is untable.
   CL_ZPK = sp.tf2zpk(*CL)
   if len(unstableRoots(CL_ZPK[1])) > 0:
      print('Unstable Closed-Loop System\n')
      return feedback(False)
   
   # If all the checks passed, proceed
   print('You have stabilized the system.\nWe will test its performance') 
   Time = np.linspace(0,2,100)
   U = 1 * np.ones_like(Time)
   Time,SR,_ = sp.lsim(CL,U,Time)
   plt.plot(Time,SR)
 
   return None

def testPID(kP,kI,kD):
   C = ([kD,kP,kI],[1.,0.])
   return testClassicalControl(P,C)

def testPD(kP,kD):
   return testPID(kP,0.,kD)
@

<<echo = <%=text_echo%>, evaluate = <%=text_evaluate%> >>=
# Change these gain values to stabilize your system
kP = 0.
kD = 0.

checker.testPD(kP,kD)

@ 

<<echo = <%=debug_echo%>, evaluate = <%=debug_evaluate%>>>=

kP = 1.
kD = 10.

checker.testPD(kP,kD)
@ 

<<echo=<%=debug_echo%>,evaluate = <%=debug_evaluate%> >>=

# This is just some testing code
import systems as dsys
import scipy.signal as sp
reload(dsys)

P = dsys.dcMotor().sys
P_tf = sp.ss2tf(*P)

omega_0 = 2.
zeta = .7
P = ([1.],[1./(omega_0**2), 2 * zeta / omega_0 , 1])
@ 
