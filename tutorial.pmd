# Oh hey. 

Welcome to the Discover STEM session on Programming for Robot Control.


<<switches, echo=False, evaluate=True>>=
text_echo = text_mode and not debug_mode
text_evaluate = False
code_echo = not text_mode
code_evaluate = False
debug_echo = debug_mode
debug_evaluate = debug_mode
@ 



# Introduction to Python

## Jupyter Notebooks

If you're reading this, you are looking at a "Jupyter notebook". Jupyter notebooks allow you to easily mix text, 
$\sqrt{math}$, and code:

<< echo=<%=text_echo%>, evaluate=<%=text_evaluate%> >>=
complex_calculation = 1 + 1
print('The result of this calculation is: ', complex_calculation)
@ 

The block above is known as a "code cell". There are a few ways to run a code cell. 
* Click the "Run" button at the top of the page.
* Click the "Run" button to the left of the cell. (Older versions of Jupyter notebooks might not have these buttons.)
* Press `Shift-Enter` on the keyboard.

Read the code in the cell above, and think about what you think it will do. Then run the cell and see what *really* happens. 

The cell below loads the code that we will use in the tutorial. Run this cell. 

<<echo=<%=text_echo%>,evaluate = <%=text_evaluate%> >>=
# Definitely do run this cell.
import discoverSTEM.checker as checker
import discoverSTEM.gantryGame as gantryGame
import matplotlib.pyplot as plt
%matplotlib inline
print('We are ready to roll.')
@

Did you run the cell?


<<echo=<%=debug_mode%>, evaluate = <%=debug_mode%> >>=
import discoverSTEM.checker as checker
import discoverSTEM.gantryGame as gantryGame
import discoverSTEM.utils as ut

from importlib import reload
reload(checker)
reload(ut)
reload(gantryGame)

import matplotlib.pyplot as plt
%matplotlib inline

@ 

## What is Python?

Python is a sweet programming language. We will use it for the tutorial.

The first program you'll see in any programming language is "Hello, World!". All it does is print "Hello, World!" to the screen. 

https://en.wikipedia.org/wiki/%22Hello,_World!%22_program

Here is how "Hello, World!" works in Python. Run the cell below.

<<echo = <%=text_echo%>, evaluate = <%=text_evaluate%> >>=
print('Oh hey.')
@ 

That can't be right. It was supposed to print "Hello, World!". We got something else. 
Fix the code above to get a real "Hello, World!" program. 

Now we will explore some of the basics of Python.

### Comments

As with most languages, Python allows you to make comments. 
Comments are pieces of text that you can put in your code to make it easier to read. 
However, they don't do anything when you run the code. Try to guess what the code below will do. 

<<echo = <%=text_echo%>, evaluate = <%=text_evaluate%> >>=
# This is a comment.

# Let's calculate the force on a particle accelerated by gravity
mass = 10. 
acceleration = -9.8 
force = mass * acceleration 

print('May the',force,'be with you')
@ 

Run the cell to see if your guess was correct. 

### Variables

The the code cell above, `mass`, `acceleration`, and `force` are all variables. Variables can be used to keep track of data 
during computations. It is always good practice to make variable names which are easy to understand. Consider, instead, the following code, which does the same thing.

<<echo =<%=text_echo%>, evaluate = <%=text_evaluate%> >>=
# This is a comment.

# Let's calculate the force on a particle accelerated by gravity
asdofdoadkfla = 10.0
asdgasddoaijgda = -9.8
aslgpasdlkg = asdofdoadkfla * asdgasddoaijgda

print('May the',aslgpasdlkg,'be with you')
@ 

Even with the comments, it is not all that obvious what the variables are supposed to mean.

### Question

Make a variable called `the_answer`, which holds the answer to [life, the universe and everything](https://en.wikipedia.org/wiki/42_(number)).  
<<echo=<%=text_echo%>, evaluate=<%=text_evaluate%> >>=
# Make your variable here



# Don't modify the code below here
# This is what checks your work.
checker.check_the_answer(the_answer)
@

<<echo = <%=debug_echo%>, evaluate = <%=debug_evaluate%> >>=
# Make your variable here

the_answer = 42
checker.check_the_answer(the_answer)
@

<<echo = <%=code_echo%>, evaluate = <%=code_evaluate%>>>=
def check_the_answer(ans):
    if isinstance(ans,int):
        if ans == 42:
            print('Yes.')
            return
    print('No. You may wish to contemplate this for a few million more years.')
    return
        
        
@ 

### Lists and Loops

Computers are great at doing the same thing over and over and over and over and over again. 
One of the main tricks to get repetitive behavior in a program is called a "for loop". 

<<echo=<%=text_echo%>, evaluate=<%=text_evaluate%> >>=
# This is a list.
margotList = ['Margot','is', 'a', 'dog']

for word in margotList:
    print(word)
@ 

This is Margot. 
<img src="figures/margot.JPG" alt="Margot" width="300px"/>

Here is another example of working with lists and loops.

<<echo=<%=text_echo%>, evaluate=<%=text_evaluate%>>>=
print('Here is a list of the first five non-negative numbers') 
numList = range(5)
print(numList)

# Here is an empty list
squareList = []

# We will fill the list using the append command
for num in numList:
    # This is how exponents are written in Python
    numSquared = num**2
    squareList.append(numSquared)
    
print('Here is a list of the first five squared numbers')
print(squareList)
@ 

### Functions



<< echo=<%=text_echo%>, evaluate = <%=text_evaluate%> >>=
# This is a simple function
def squared(x):
    return x**2

print(1,'squared is',squared(1))
print(2,'squared is',squared(2))
print(the_answer,'squared is',squared(the_answer))
@ 

### Question 


Write a function called `cubed` that takes a number, $x$, as input and returns its cube, $x^3$.

<<echo=<%=text_echo%>, evaluate = <%=text_evaluate%> >>=
# Write your code here. 


# Don't modify the line below. It is used to test your code.
checker.check_cubed(cubed)
@ 

<<echo=<%=debug_mode%>, evaluate = True>>=
cubed = lambda x : x**3
checker.check_cubed(cubed)
@ 

<<echo=<%=code_echo%>,evaluate = <%=code_evaluate%> >>=
# This is the main checker code 
import numpy as np
import numpy.random as rnd
import scipy.linalg as la
import scipy.signal as sp

import discoverSTEM.gantryGame as gantryGame
import matplotlib.pyplot as plt
import scipy.signal as sp
import discoverSTEM.utils as ut



def feedback(result):
   if result:
      print("oh yeah.")
   else:
      print("nope")
   return result
def check_array_equality(X,X_test,tol=1e-3,ord=2):
   err = la.norm(X-X_test,ord=ord)

   passed = err < tol
   feedback(passed)
   return passed
      

def check_cubed(fun):
   X = rnd.randn(10)
   Y = X**3
   Y_test = np.array([fun(x) for x in X])
   check_array_equality(Y,Y_test)
@ 
# Dynamic Modeling
Things that move or change over time are called *dynamic systems*. Here are some dynamic systems
* Robots
* Gas prices
* The wolf population

In order to study the behavior of dynamic systems, we need some way of
describing how things change from one instant of time to the
next. We'll need some math in order to do that. 

## Math background

The next few questions will step through the basics of simulation.

### Question
A few days ago, I left my house at 4 AM and walked 25 miles per hour. 
How far did I walk by midnight?

<<echo=<%=code_echo%>, evaluate=<%=code_evaluate%> >>=
def check_distance(miles):
    milesTrue = 25 * 20
    if np.abs(miles-milesTrue) < 1e-3:
        print('Yes. And I would walk 500 more.')
    else:
        print('No. Check your calculations again.')
@ 

<<echo=<%=text_echo%>, evaluate=<%=text_evaluate%> >>=
# Put your answer in a variable called distance.
# distance should be in miles. 



# Again, don't change this line. This is the checker
checker.check_distance(distance)
@ 

<<echo=<%=debug_echo%>, evaluate=<%=debug_evaluate%> >>=
# Put your answer in a variable called distance.
# You can make other variables to help with the calculation.

distance = 500

# Again, don't change this line. This is the checker
checker.check_distance(distance)
@

### Question

The next day, I started walking at midnight and I walked for 10 hours. This day however, I didn't walk the same speed the whole time. Instead, I had a different speed every hour. Make a list  called `cumulative_distance` that shows the total distance I travelled at each hour. The list should start at 0 and have a total of 11 entries.  

<<echo=<%=code_echo%>, evaluate=True>>=
speeds = [40, 30, 30, 25, 25, 35, 30, 20, 10, 5]
def checkCD(ans):
    true_ans = np.hstack([0,np.cumsum(speeds)])
    check_array_equality(np.array(ans),true_ans)
    plt.plot(ans)
@ 

<<echo=<%=text_echo%>, evaluate=<%=text_evaluate%> >>=
# These are my walking speeds.
speeds = <%=speeds%>

# So, the first few entries of the list should be
# 0, <%=speeds[0]%>, <%=speeds[0]+speeds[1]%>, . . . 



checker.checkCD(cumulative_distance)
@

<<echo=<%=debug_mode%>, evaluate=<%=debug_mode%>>>=
speeds = <%=speeds%>

cur_distance = 0
cumulative_distance = [cur_distance]
for s in speeds:
    cur_distance = s + cur_distance
    cumulative_distance.append(cur_distance)
    
checker.checkCD(cumulative_distance)
@ 

### Question

I took a rest for a few hours, and then starting at noon, I walked for 10 more hours. This time, however, I changed my speed every minute. 

<<echo=<%=code_echo%>, evaluate = <%=code_evaluate%> >>=
numSteps = 60 * 10
dt = 1./60.
Time = np.linspace(0,10-dt,numSteps)
minuteTimes = Time
minuteSpeeds = np.exp(-.5 * minuteTimes)*(1 + np.sin( 2*np.pi*Time))
minuteSpeeds = 250 * minuteSpeeds / (dt * np.sum(minuteSpeeds))

def checkMD(ans):
    trueAns = np.hstack([0,dt * np.cumsum(minuteSpeeds)])
    check_array_equality(ans,trueAns)
    plt.plot(dt * np.arange(numSteps+1),ans)
@ 

<<echo=<%=text_echo or debug_echo%>, evaluate=<%=debug_evaluate%> >>=
# Run this cell to see how fast I walked.
minuteTimes = checker.minuteTimes
minuteSpeeds = checker.minuteSpeeds
plt.plot(minuteTimes,minuteSpeeds)
@

Now make a list called `minute_distance` that contains the cumulative distance that I walked at each minute. 
As before, your list should start from zero, leading to a total of <%=60*10 + 1%> entries. 

<<echo=<%=text_echo%>, evaluate=<%=text_evaluate%> >>=
# Make your list here
# You will need to use the list minuteSpeeds.
# As long as you have run the previous cell
# minuteSpeeds should be available



checker.checkMD(minute_distance)
@ 

<<echo=<%=debug_echo%>, evaluate=<%=debug_evaluate%> >>=

dt = 1./60.

cur_distance = 0.
minute_distance = [cur_distance]

for s in minuteSpeeds:
    cur_distance = cur_distance + dt * s
    minute_distance.append(cur_distance)
    
checker.checkMD(minute_distance)
@ 

## Derivatives, integrals, and all that. 








## Why we need feedback

Let's try pushing a block around on a low friction surface. 
This model is sometimes known as "Cartesian coordinate robot", a "linear robot", or a "gantry robot". 
These types of robots are commonly used in 3D printing applications.  

https://en.wikipedia.org/wiki/Cartesian_coordinate_robot

<<echo=<%=debug_echo or text_echo%>, evaluate=False>>=

gantryGame.manualControl()
@ 

When you finish, a plot of the $X$ and $Y$ positions of the block is generated. 



<<echo=<%=code_echo%>, evaluate = <%=code_evaluate%> >>=

c = gantryGame.damping
P = ([1.],[1.,c,0])

def unstableRoots(p,tol=1e-8):
   return np.array([r for r in np.roots(p) if np.real(r) >= -tol])

def testClassicalControl(P,C):
   C_min = ut.minreal(C)
   P_min = ut.minreal(P)
   
   CL = ut.classicFeedback(P_min,C_min)
   CL = ut.minreal(CL) 
   

   # Stability Tests
   nP,dP = P_min
   nC,dC = C_min
   
   # First check for  pole-zero cancellations
   nL = np.polymul(nP,nC)
   dL = np.polymul(dP,dC)
  
   L_unstable = unstableRoots(dL)
   L_min = ut.minreal((nL,dL)) 
   L_min_unstable = unstableRoots(L_min[1]) 
   
   if len(L_unstable) > len(L_min_unstable):
      print('Unstable Pole-Zero Cancellation.\nYour system will be sensitive input disturbances.\n')
      return feedback(False)
   
   # Now check if the closed-loop system is untable.
   CL_ZPK = sp.tf2zpk(*CL)
   if len(unstableRoots(CL_ZPK[1])) > 0:
      print('Unstable Closed-Loop System\n')
      return feedback(False)
   
   # If all the checks passed, proceed
   print('You have stabilized the system.\nWe will test its performance\n') 
   Time = np.linspace(0,5,500)
   
   for p,e in zip(gantryGame.pos,gantryGame.error):
      U = e * np.ones_like(Time)
      Time,SR,_ = sp.lsim(CL,U,Time)
      plt.plot(Time,SR+p)
 
   plt.legend(['X','Y'],loc='best')
   plt.xlabel('Time')
   plt.ylabel('Position')
   return feedback(True)

def testPID(kP,kI,kD):
   C = ([kD,kP,kI],[1.,0.])
   return testClassicalControl(P,C)

def testPD(kP,kD):
   return testPID(kP,0.,kD)
@

<<echo = <%=text_echo%>, evaluate = <%=text_evaluate%> >>=
# Change these gain values to stabilize your system
kP = 0.
kD = 0.

checker.testPD(kP,kD)

@ 

<<echo = <%=debug_echo%>, evaluate = <%=debug_evaluate%>>>=

kP = 1.
kD = 10.

checker.testPD(kP,kD)
@ 

Play around with the various values of $k_P$ and $k_D$ to see how the performance of the simulation changes. The behavior here will be slightly different from the behavior of the earlier test. This is because the graphic simulation models disturbances on the system, while the test does not. These disturbances capture the effects such as wind and surface imperfections. 

<<echo=<%=debug_echo or text_echo%>,evaluate = False >>=
# See what happens when you change the values of kP and kD
# You can set the values in the space here.

kP = 0.
kD = 0.

# 
gantryGame.pdControl(kP,kD)
@ 

# Challenge Problems

If this is not your first rodeo, you might finish the problem early. Here are some challenge problems. 
