# Oh hey. 

Welcome to the Discover STEM session on Programming for Robot Control.


<<switches, echo=False, evaluate=True>>=
text_echo = text_mode and not debug_mode
text_evaluate = False
code_echo = not text_mode
code_evaluate = False
debug_echo = debug_mode
debug_evaluate = debug_mode
@ 



# Introduction to Python

## Jupyter Notebooks

If you're reading this, you are looking at a "Jupyter notebook". Jupyter notebooks allow you to easily mix text, 
$\sqrt{math}$, and code:

<< echo=<%=text_echo%>, evaluate=<%=text_evaluate%> >>=
complex_calculation = 1 + 1
print('The result of this calculation is: ', complex_calculation)
@ 

The block above is known as a "code cell". There are a few ways to run a code cell. 
* Click the "Run" button at the top of the page.
* Click the "Run" button to the left of the cell. (Older versions of Jupyter notebooks might not have these buttons.)
* Press `Shift-Enter` on the keyboard.

Read the code in the cell above, and think about what you think it will do. Then run the cell and see what *really* happens. 

The cell below loads the code that we will use in the tutorial. Run this cell. 

<<echo=<%=text_echo%>,evaluate = <%=text_evaluate%> >>=
# Definitely do run this cell.
import checker
import gantryGame
import matplotlib.pyplot as plt
%matplotlib inline
print('We are ready to roll.')
@

Did you run the cell?

<<echo=<%=debug_mode%>, evaluate = <%=debug_mode%> >>=
import checker
import gantryGame
import utils as ut

from importlib import reload
reload(checker)
reload(ut)
reload(gantryGame)

import matplotlib.pyplot as plt
%matplotlib inline

@ 


\

## Problem

Write a function called `cubed` that takes a number, $x$, as input and returns its cube, $x^3$.

<<echo=<%=text_echo%>, evaluate = <%=text_evaluate%> >>=
# Write your code here. 


# Don't modify this line. It is used to test your code.
checker.check_cubed(cubed)
@ 

<<echo=<%=debug_mode%>, evaluate = True>>=
cubed = lambda x : x**3
checker.check_cubed(cubed)
@ 


<<echo=<%=code_echo%>,evaluate = <%=code_evaluate%> >>=
# This is the main checker code 
import numpy as np
import numpy.random as rnd
import scipy.linalg as la
import scipy.signal as sp
import systems as dsys

def feedback(result):
   if result:
      print("oh yeah.")
   else:
      print("nope")
   return result
def check_array_equality(X,X_test,tol=1e-3,ord=2):
   err = la.norm(X-X_test,ord=ord)

   passed = err < tol
   feedback(passed)
   return passed
      

def check_cubed(fun):
   X = rnd.randn(10)
   Y = X**3
   Y_test = np.array([fun(x) for x in X])
   check_array_equality(Y,Y_test)
@ 

## Why we need feedback

Let's try pushing a block around on a low friction surface. 
This is a model of a simple gantry system. Gantry systems are commonly used in 3D printing applications. 

<<echo=<%=debug_echo or text_echo%>, evaluate=False>>=

gantryGame.manualControl()
@ 

When you finish, a plot of the $X$ and $Y$ positions of the block is generated. 



<<echo=<%=code_echo%>, evaluate = <%=code_evaluate%> >>=
import gantryGame
import matplotlib.pyplot as plt
import scipy.signal as sp
import utils as ut

c = gantryGame.damping
P = ([1.],[1.,c,0])

def unstableRoots(p,tol=1e-8):
   return np.array([r for r in np.roots(p) if np.real(r) >= -tol])

def testClassicalControl(P,C):
   C_min = ut.minreal(C)
   P_min = ut.minreal(P)
   
   CL = ut.classicFeedback(P_min,C_min)
   CL = ut.minreal(CL) 
   

   # Stability Tests
   nP,dP = P_min
   nC,dC = C_min
   
   # First check for  pole-zero cancellations
   nL = np.polymul(nP,nC)
   dL = np.polymul(dP,dC)
  
   L_unstable = unstableRoots(dL)
   L_min = ut.minreal((nL,dL)) 
   L_min_unstable = unstableRoots(L_min[1]) 
   
   if len(L_unstable) > len(L_min_unstable):
      print('Unstable Pole-Zero Cancellation.\nYour system will be sensitive input disturbances.\n')
      return feedback(False)
   
   # Now check if the closed-loop system is untable.
   CL_ZPK = sp.tf2zpk(*CL)
   if len(unstableRoots(CL_ZPK[1])) > 0:
      print('Unstable Closed-Loop System\n')
      return feedback(False)
   
   # If all the checks passed, proceed
   print('You have stabilized the system.\nWe will test its performance\n') 
   Time = np.linspace(0,5,500)
   
   for p,e in zip(gantryGame.pos,gantryGame.error):
      U = e * np.ones_like(Time)
      Time,SR,_ = sp.lsim(CL,U,Time)
      plt.plot(Time,SR+p)
 
   plt.legend(['X','Y'],loc='best')
   plt.xlabel('Time')
   plt.ylabel('Position')
   return feedback(True)

def testPID(kP,kI,kD):
   C = ([kD,kP,kI],[1.,0.])
   return testClassicalControl(P,C)

def testPD(kP,kD):
   return testPID(kP,0.,kD)
@

<<echo = <%=text_echo%>, evaluate = <%=text_evaluate%> >>=
# Change these gain values to stabilize your system
kP = 0.
kD = 0.

checker.testPD(kP,kD)

@ 

<<echo = <%=debug_echo%>, evaluate = <%=debug_evaluate%>>>=

kP = 1.
kD = 10.

checker.testPD(kP,kD)
@ 

Play around with the various values of $k_P$ and $k_D$ to see how the performance of the simulation changes. The behavior here will be slightly different from the behavior of the earlier test. This is because the graphic simulation models disturbances on the system, while the test does not. These disturbances capture the effects such as wind and surface imperfections. 

<<echo=<%=debug_echo or text_echo%>,evaluate = False >>=
# See what happens when you change the values of kP and kD
# You can set the values in the space here.

kP = 0.
kD = 0.

# 
gantryGame.pdControl(kP,kD)
@ 

# Challenge Problems

If this is not your first rodeo, you might finish the problem early. Here are some challenge problems. 
